# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# Add local bin to PATH (for Claude, etc.)
export PATH="$HOME/.local/bin:$PATH"

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=10000
HISTFILESIZE=20000

# Clean terminal logging
HISTTIMEFORMAT=""

# Function to log user commands only
log_user_command() {
    local last_cmd=$(history 1 | tail -1 | sed 's/^[ ]*[0-9]*[ ]*//')
    # Filter out kitty integration and internal commands
    if [[ -n "$last_cmd" && "$last_cmd" != "$PREV_CMD" && 
          "$last_cmd" != *"printf"* && "$last_cmd" != *"builtin"* && 
          "$last_cmd" != *"_ksi_"* && "$last_cmd" != *"declare"* ]]; then
        echo "$(date '+%F %T') [$(pwd)] $last_cmd" >> "$HOME/scripts/docs/terminal_history.log"
        PREV_CMD="$last_cmd"
    fi
}

PROMPT_COMMAND="log_user_command"

# Alias for full session logging with output
alias start-full-log='script -a ~/scripts/docs/session_$(date +%Y%m%d_%H%M%S).log'

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
#force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# colored GCC warnings and errors
#export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# some more ls aliases
unalias ll 2>/dev/null
ll() {
    local output
    output=$(LC_COLLATE=C ls -alF --color=always "$@")
    echo "$output" | head -1
    echo "$output" | tail -n +2 | awk '
        {
            filename = ""
            for (i = 9; i <= NF; i++) filename = filename (i > 9 ? " " : "") $i
            gsub(/[\/\*@]$/, "", filename)
            is_dir = /^d/ ? "0" : "1"
            if (filename ~ /^\./) cat = "0"
            else if (filename ~ /^[^A-Za-z]/) cat = "1"
            else cat = "2"
            printf "%s%s\t%s\t%s\n", is_dir, cat, filename, $0
        }
    ' | LC_COLLATE=C sort -t$'\t' -k1,1 -k2,2 | cut -f3-
}
alias la='ls -A'
alias l='ls -CF'
alias octave='git clone https://github.com/waybetterengineering/octave.git'

#chromium
alias homeassistant='chromium http://homeassistant.local:8123/dashboard-michgan/0 --new-window'
alias youtube='chromium http://www.youtube.com --new-window'
alias reddit='chromium http://www.reddit.com --new-window'
alias gmail='chromium http://gmail.com --new-window'
alias perplexity='chromium https://www.perplexity.ai/ --new-window'
alias discord='chromium https://www.discord.com --new-window'
alias web='chromium https://google.com --new-window'
alias github='chromium https://github.com --new-window'

#games
alias gameboy='__NV_PRIME_RENDER_OFFLOAD=1 __GLX_VENDOR_LIBRARY_NAME=nvidia mgba-qt'
alias osrs='DRI_PRIME=1 $HOME/.local/bin/RuneLite.AppImage'

# GPU Control Aliases
alias gpu-on='sudo prime-select nvidia && echo "GPU switched to NVIDIA. Reboot required."'
alias gpu-off='sudo prime-select intel && echo "GPU switched to Intel. Reboot required."'
alias gpu-auto='sudo prime-select on-demand && echo "GPU set to on-demand mode. Reboot required."'
alias gpu-status='echo "Prime mode: $(prime-select query)" && echo "GPU power: $(cat /sys/bus/pci/devices/0000:01:00.0/power/control)" && echo "bbswitch: $(cat /proc/acpi/bbswitch 2>/dev/null || echo not-available)"'

# Wayland GPU
export WLR_NO_HARDWARE_CURSORS=1
export LIBVA_DRIVER_NAME=nvidia
export XDG_SESSION_TYPE=wayland
export GBM_BACKEND=nvidia-drm
export __GLX_VENDOR_LIBRARY_NAME=nvidia


# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

# Source greeting script (uncomment one)
source ~/scripts/terminal-shell/greetings/fetch.sh
#source ~/scripts/terminal-shell/greetings/wave.sh
#source ~/scripts/terminal-shell/greetings/moon.sh
#source ~/scripts/terminal-shell/greetings/constellation.sh
#source ~/scripts/terminal-shell/greetings/wizard.sh
#source ~/scripts/terminal-shell/greetings/tree.sh
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
# Terminal session logging aliases
alias log-session='script -a ~/scripts/session_$(date +%Y%m%d_%H%M%S).log'
alias view-logs='ls -la ~/scripts/*.log'

# Only show tree automatically on first shell startup
if [ -z "$SYSTEM_GREETING_SHOWN" ]; then
    export SYSTEM_GREETING_SHOWN=1
    system_greeting
fi

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion